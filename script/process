#!/usr/bin/env ruby
#/ Usage: script/process --crops CROPLIST INPUT
#/ CROPLIST is first column from harvest spreadsheet.
#/ INPUT is a typed version of harvest sheet.
#/ Output is one of these:
#/   A. List of crops to add.
#/   B. The values to put into harvest sheet.

require 'optparse'

def main(input:, crop_list:)
  input_data = parse_input_file(input)
  crop_list_data = parse_crop_list(crop_list)

  # Check for unmatched crops
  unmatched_crops = input_data.keys - crop_list_data
  if unmatched_crops.any?
    # Output A: List of crops to add
    $stderr.puts "** These crops aren't in the harvest sheet.",
      "** Add rows for them, then copy the first column to #{crop_list},",
      "** then re-run this program.",
      "",
      unmatched_crops.map { |crop| "  #{crop}" }
    exit 1
  else
    # Output B: Values aligned with crop list
    crop_list_data.each do |crop|
      puts format_crop(crop, input_data[crop])
    end
  end
end

def parse_input_file(input_file)
  res = {}
  File.readlines(input_file).each do |line|
    begin
      crop, quantity = line.strip.split('|')
      crop = crop.strip
      quantity = parse_quantity(quantity)
      if quantity > 0
        res[crop] = res.fetch(crop, 0.0) + quantity
      end
    rescue => e
      raise "Error parsing #{line.strip.inspect}: #{e.message}"
    end
  end
  res
end

def parse_quantity(str)
  str.split("*").map { |m|
    m.split("+").map { |x|
      parse_f_strict(x)
    }.sum
  }.inject { |a, b| a * b }
end

def parse_f_strict(str)
  if str =~ /\A\s*(\d*\.?\d*)\s*\z/
    $1.to_f
  else
    raise "Invalid quantity: #{str.inspect}"
  end
end

def parse_crop_list(crop_list_file)
  crops = File.readlines(crop_list_file).map(&:strip)
  case
  when crops.empty?
    raise "#{crop_list_file}: error, this file must include all of the values from the first column of the harvest spreadsheet"
  when crops[0] != "Week number:"
    raise "#{crop_list_file}: error, this file must include all of the values from the first column of the harvest spreadsheet"
  when crops[1] != "Week ending on:"
    raise "#{crop_list_file}: error, this file must include all of the values from the first column of the harvest spreadsheet"
  end
  # drop the two header rows
  crops.shift; crops.shift
  crops
end

def format_crop(crop, quantity)
  return "" if quantity.nil?
  unit = crop.split(",").last.strip
  case unit
  # Add units to this list if the quantity can be fractional.
  when "lb"
    if (quantity - quantity.to_i) < 0.1
      "%d" % quantity.to_i
    else
      "%0.1f" % quantity
    end
  # Add units to this list if the quantity is always an integer.
  when "bag", "bags", "bouquets", "bulbs", "bunches",
       "clamshell", "count", "ea", "each", "heads", "lettuce heads",
       "pint", "pt", "stems", "tops"
    "%d" % quantity.to_i
  else
    raise "Unknown unit in #{crop.inspect}"
  end
end

options = {crop_list: "crops.txt"}
OptionParser.new do |opts|
  opts.banner = "Usage: script/process --crops CROPLIST INPUT"
  opts.on("--crops CROPLIST", "File containing list of valid crops (default is crops.txt)") do |c|
    options[:crop_list] = c
  end
end.parse!

if ARGV.size != 1
  puts "Error: Expected exactly one input file"
  exit 1
end
options[:input] = ARGV[0]

main(**options)
